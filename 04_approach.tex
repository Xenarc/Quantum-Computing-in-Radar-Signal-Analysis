\section{Artefact Development Approach}~\label{sec:approach}

% ---------------- EXPERIMENT 1 ---------------- %
\subsection{Experiment 1}
\todojc{We need some paragraph describing what is the aim of the subsections and what we are going to find in them.}
\todojc{Also this chapter is to include some details of the "development artefact", which are the details of your development environment, some description of your program design, some code decisions, etc.}

The incident signal prior to sampling is a continuous complex-valued function
$x : \mathbb{R} \rightarrow \mathbb{C}, t \mapsto x(t)$,
where $x(t)$ represents the complex amplitude of the signal at any given time, $t \in \mathbb{R} > 0$.

After being sampled, the signal is discrete.
$x : \mathbb{N} \rightarrow \mathbb{C}, t \mapsto x[t]$,
where $x[n] = x(n T_s)$, the $n^{th}$ sample of the signal, $n$ is an integer representing the sample index, and $T_s$ is the sampling period (i.e., $T_s = 1/f_s$).

Let $\mathbf{x}$ be the buffer of samples $x_n=x[n]$.

The goal of this encoding is to prepare the sample buffer for quantum processing.
Several methods will be implemented and evaluated.

\textbf{Basis encoding}

\textbf{Amplitude encoding}

\todo{Still revising the particulars here... (also a WIP as I'm missing some encoding methods)}
\todojc{This looks like "amplitude encoding"}
\todojc{Note that "basis encoding" is to encode a value as a series of qubit states (good for a single value represented as its bits, e.g. initialising q0=|0>, q1=|1>, q2=|1> encodes number 6), or multiple values as groups of qubits, we can also use superposition to encode multiple values}The simplest of all non-trivial quantum encoding methods, basis encoding, maps a binary string $x \in {\{0,1\}}^n$ as coefficients of basis states.

Let $\vert b_n \rangle$ be the $n^{th}$ orthonormal basis for a $N$-dimensional quantum system.
Then any state of the system can be written as a linear combination of the basis states:
\begin{equation}
    \displaystyle{
        \phi: \mathbb{R}^n \rightarrow | \mathbf{x} \rangle =
        \sum_{i=0}^{N}
            c_i | b_i \rangle
    }
\end{equation}
Where $c_i$ are complex coefficients of the basis states which satisfy the normalisation condition
\begin{equation}
    \displaystyle{\sum_{i=1}^n |c_i|^2 = 1}
\end{equation}

\todojc{All those examples would be improved if they could be related to your problem of signal processing, e.g. you could include a small fragment of your generated radar signal (even if it is 4 values) and say that this is the case}For example, encoding $\mathbf{x} = (1, -1+i\sqrt{3}, 1, 1+i\sqrt{3})$

The normalisation condition must be be upheld.
One way to ensure this is to divide each element of the vector by the Euclidean norm.
\begin{equation}
    \displaystyle{\mathbf{x} = \frac{1}{\sqrt{6}}(1, -1+i\sqrt{3}, 1, 1+i\sqrt{3})}
\end{equation}
Encoding this into a 2-qubit system implies multiplying each element by the basis states: $|00\rangle, |01\rangle, |10\rangle, |11\rangle$.
\todojc{And since each basis state's amplitude defines a value therefore this is called "amplitude encoding"}Therefore, 
\begin{equation}
    \displaystyle{
        | \mathbf{x} \rangle =
        \frac{1}{\sqrt{6}}
        (
            |00\rangle +
            (-1 + i\sqrt{3}) |01\rangle +
            |10\rangle +
            (1 + i\sqrt{3}) |11\rangle
        )
    }
\end{equation}
\todojc{What would the circuit look like?}
\todojc{What would its measurement look like?}

\textbf{Angle encoding}

\todojc{BTW, in Qiskit "initialize" instruction and "StatePreparation" class (to create a gate) can assist in amplitude encoding}Quantum amplitude encoding represents classical information as amplitudes of quantum states.
For $n$ qubits, encoding a classical vector $x \in \mathbb{C}^{n}$ into a quantum state $\vert x \rangle$ is described by:

$|x\rangle = \frac{1}{\sqrt{N}} \sum{_n^N}  x_n \vert y \rangle$


% The operation of encoding is one which maps to a Hilbert space, $\mathcal{H}$.
We can define a map $\phi: \mathbb{R}^n \rightarrow \mathcal{H}$ that takes a vector of length $n$ (i.e., the length of the \todojc{What is a "buffer"?}\textbf{buffer}) and maps it to a vector in the Hilbert space, $\mathcal{H}$.
% The goal of any quantum encoder is to satisfy:
One common choice for $\phi$ is to use the Fourier transform to map the buffer into a frequency representation, and then use the resulting frequency coefficients as the coordinates in $\mathcal{H}$. \todojc{I think we have some mix up here, the following seem to be rotations, so perhaps rotation encoding? You may need to clarify it, as long as the amplitudes of possible states (e.g. |00>, |01>, |10>, |00>) of the entire circuit represent the intended values - here frequencies - then this indeed is an amplitude encoding}This can be expressed mathematically as:
\begin{equation}
\phi(x) = \sum_{k=0}^{n-1} x_k e^{i2\pi k t / n}
\end{equation}
This represents the summation of the product of each sample $x_k$ with a complex exponential term $e^{i2\pi k t / n}$, where $t$ ranges from 0 to $n-1$ and $k$ ranges from 0 to $n-1$.

\todojc{What would the circuit look like}



% --------------
%%% Qualitative stuff / post hoc evals
% For although subsequent experimental trials and post hoc evaluation of the encoding methods remain as important means of assessing its suitability to the broader question, each experiment is designed to be independent of the results of the previous.
% In other words, while the success of the subsequent analyses hinges only somewhat on the quantitative comparison of encoding methods, it is the understanding of <...>. 
% Is is empirical trial and post hoc evaluation that measure this. 

% The method consists of creating a GNU-Radio block that permits the input of complex-valued samples into a buffer. The processing of samples is then done in Python and Qiskit within that block, and finally, outputted to a buffer where it is recorded.
-----------------------







% It may also be suggested that a frequency-domain input space be explored, in which case, the same experimental methodology should be applied, substituting IQ for a time varying frequency input. The reason for proposing a frequency-domain input signal is due to the general bandwidth limitation of practical IQ measurements as well as the more representative nature of frequency plots for radar signals.

\subsection{Experiments 2 & 3}

The stages in the of development the artefact are:
\begin{quote}
    \textit{
        \begin{enumerate}
            \item Encode the input data into the state of a set of qubits.
            \item Bring the qubits into superposition over many states (i.e., use quantum superposition).
            \item Apply an algorithm (or oracle) simultaneously to all the states (i.e., use quantum entanglement amongst the qubits); at the end of this step, one of these states holds the correct answer.
            \item Amplify the probability of measuring the correct state (i.e., use quantum interference).
            \item Measure one or more qubits.
        \end{enumerate}
        - Quantum computing for finance: Overview and prospects: Román Orús, Samuel Mugeld, Enrique Lizaso \todo{Add this to citations}
    }
\end{quote}

Instead of descretising signals into definite PDW's, the Quantum system might be able to generate a superposition of all possibilities of potential signal parameters at once. Further processing such as pulse detection and de-interleaving may be able to be conducted at once. This approach would investigate whether quantum methods can be used to place observed radar modes into a super-positioned and continuous state.